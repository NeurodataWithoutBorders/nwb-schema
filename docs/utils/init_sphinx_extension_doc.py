from subprocess import check_call, CalledProcessError
import argparse
import os

#######################################
#  Define bool type for argparse
#######################################
def bool_type(argument):
    """
    Implement conversion of boolean input parameters since
    arparse (or bool, depending on the point of view), do not
    handle bool as a type in an intuitive fashion.

    :param argument: The argument to be parsed to a boolean
    :return: The converted value
    """
    try:
        bool(int(argument))
    except ValueError:
        if argument in ('TRUE', 'true', 'True', 't', 'T'):
            return True
        elif argument in ('FALSE', 'false', 'False', 'f', 'F'):
            return False
        else:
            raise ValueError('Parameter could not be converted to type bool')

#######################################
#  Define formatter for argparse
#######################################
class RawDescriptionDefaultHelpArgParseFormatter(argparse.ArgumentDefaultsHelpFormatter,
                                                 argparse.RawDescriptionHelpFormatter):
    """
    Simple derived formatter class for use with argparse used by the
    cl_analysis_driver class. This formatter combines the default
    argparse.ArgumentDefaultsHelpFormatter and
    argparse.RawDescriptionHelpFormatter
    for formatting arguments and help descriptions.

    """
    pass

#####################################################
#  Create Readme.md
#####################################################
def get_readme(custom_description, custom_release_notes, copy_utils):
    readme_txt = \
"""
**What to do next**

* **Generate the format docs** To generate the format documentation from the YAML/JSON format specs run ``make apidoc``
* **Generate the documentation** To generate the HTML version of your documentation run ``make html``. For further details see below
"""

    if custom_description:
        readme_txt += "* **Edit your custom description:** Edit ``%s`` to add your custom description of your format/extension\n" % ('source/%s' % custom_description)

    if custom_release_notes:
        readme_txt += "* **Edit your custom release notes:** Edit ``%s`` to add your custom release notes of your format/extension\n" % ('source/%s' % custom_release_notes)

    readme_txt += "* **Edit the build configuration** Edit ``source/conf.py`` to customize your build configuration\n"

    if copy_utils:
        readme_txt += "* **Customize document autogeneration** The autogeneration is controlled by a number of settings in ``conf.py`` described below. The Python utilities used to autogenerate Sphinx docs from the YAML/JSON specification sources are include in ``utils/generate_format_docs.py``\n"
    else:
        readme_txt += "* **Customize document autogeneration** The autogeneration is controlled by a number of settings in ``conf.py`` described below.\n"

    readme_txt += \
"""

**Overview**

The specification documentation uses Sphinx [http://www.sphinx-doc.org/en/stable/index.html](http://www.sphinx-doc.org/en/stable/index.html)

**Rebuilding All**

To rebuild the full documentation in html, latex, and PDF simply run:

```make fulldoc```

This is a convenience function that is equivilant to:

```
make allclean
make apidoc
make html
make latexpdf
```

**Generating the format documentation from the format spec**

The format documentation is auto-generated from the format specification (YAML/JSON) sources via:

```make apidoc```

This will invoke the script:

```python source/generate_format_docs.py```

The script automatically generates a series of .rst, .png, and .pdf files that are stored in the folder ```source/format_auto_docs```. The generated .rst files are included in ```source/format.rst``` and the png and pdf files are used as figures in the autogenerated docs. The folder ```source/format_auto_docs``` is reservered for autogenerated files, i.e., files in the folder should not be added or edited by hand as they will be deleted and rebuilt during the full built of the documentation.

By default the Sphinx configuration is setup to always regenerate the sources whenever the docs are being built (see next section). This behavior can be customized via the ```spec_doc_rebuild_always``` parameter in ```source/conf.py```

**Building a specific document type**

To build the documentation simply:

```make <doctype>```

where ```<doctype>``` is, e.g., ```latexpdf```, ```html```, ```singlehtml``` or ```man```. For a complete list of supported doc-types see:

```make help```

**Cleaning up**

```make clean``` cleans up all builds of the documentation located in ```_build```.

```make allclean``` cleans up all builds of the documentation located in ```_build``` as wellas  all autogenerated sources stored in ```source/format_auto_docs```.

**Configuration**

The build of the documentation can be customized via a broad range of Sphinx options in:

```source/conf_doc_autogen.py```

In addition to standard Sphinx options, there are a number of additional options used to customize the content and structure of the autogenerated documents, e.g.:

* ```spec_show_yaml_src``` Boolean indicating whether the YAML sources should be included for the different neurodata types
* ```spec_show_json_src``` Boolean indicating whether the JSON sources should be included for the different neurodata types
* ```spec_generate_src_file``` Boolen indicating whether the YAML/JSON sources of the neurodata_types should be rendered in a separate section (True) or in the same location as the main documentation
* ```spec_show_hierarchy_plots ``` Boolean indicating whether we should generate and show figures of the hierachy defined by the specifications as part of the documentation
* ```spec_file_per_type``` Boolean indicating whether we should generate separate .inc reStructuredText for each neurodata_type (True)
or should all text be added to the main file (False)
* ```spec_show_subgroups_in_tables``` Should subgroups of the main groups be renderd in the table as well. Usually this is disabled since groups are rendered as separte sections in the tex
* ```spec_appreviate_main_object_doc_in_tables``` Appreviate the documentation of the main object for which a table is rendered in the table. This is commonly set to True as doc of the main object is alrready rendered as the main intro for the section describing the object
* ```spec_show_title_for_tables``` Add a title for the table showing the specifications.
* ```spec_show_subgroups_in_seperate_table``` Should top-level subgroups be listed in a seperate table or as part of the main dataset and attributes table
* ```spec_table_depth_char``` Char to be used as prefix to indicate the depth of an object in the specification hierarchy. NOTE: The char used should be supported by LaTeX.
* ```spec_add_latex_clearpage_after_ndt_sections``` Add a LaTeX clearpage after each main section describing a neurodata_type. This helps in LaTeX to keep the ordering of figures, tables, and code blocks consistent in particular when the hierarchy_plots are included.
* ```spec_resolve_type_inc``` Resolve includes to always show the full list of objects that are part of a type (True) or to show only the parts that are actually new to a current type while only linking to base types (False)

In addition, the location of the input format specification can be customized as follows:


* ```spec_input_spec_dir```  Directory where the YAML files for the namespace to be documented are located
* ```spec_input_namespace_filename```  Name of the YAML (or JSON) file with the specification of the Namespace to be documented
* ```spec_input_default_namespace``` Name of the default namespace in the file

Finally, the name and location of output files can be customized as follows:


* ```spec_output_dir```  Directory where the autogenerated files should be stored
* ```spec_output_master_filename```  Name of the master rst file that includes all the autogenerated docs
* ```spec_output_doc_filename```  Name of the file where the main documentation goes
* ```spec_output_src_filename```  Name of the file where the sources of the format spec go. NOTE: This file is only generated if spec_generate_src_file is enabled
* ```spec_output_doc_type_hierarchy_filename```  Name of the file containing the type hierarchy. (Included in spec_output_doc_filename)

In the regular Sphinx ```source/conf.py``` file we can then also set:

* ```spec_doc_rebuild_always``` Boolean to define to always rebuild the source docs from YAML when doing a regular build of the sources (e.g., via ```make html```) even if the folder with the source files already exists

"""
    return readme_txt

#####################################################
#  Create text for file describing RTD theme fixes
#####################################################
def get_theme_overwrites():
    return \
"""
/* override table width restrictions */
@media screen and (min-width: 767px) {

   .wy-table-responsive table td {
      /* !important prevents the common CSS stylesheets from overriding
         this as on RTD they are loaded after this stylesheet */
      white-space: normal !important;
   }

   .wy-table-responsive {
      overflow: visible !important;
   }
}

"""

#######################################
#  Create text for the format.rst file
#######################################
def get_format_rst(spec_output_dir, output_master, project, custom_description=None, custom_release_notes=None):
    heading = ""
    for i in range(len(project)):
        heading += '*'

    format_rst_text = \
"""
.. _%s:

%s
%s
%s

Version |release| |today|

.. .. contents::
""" % (project.replace(' ', '_'),  heading, project, heading)
    if custom_description is not None:
        format_rst_text += \
"""
.. include:: format_description.rst
"""
    format_rst_text += \
"""
.. include:: %s/%s
""" % (spec_output_dir.rstrip('/'), output_master)
    if custom_release_notes is not None:
        format_rst_text += \
"""
.. include:: %s
""" % custom_release_notes

    return format_rst_text


#######################################
#  Create text for the index.rst file
#######################################
def get_index_rst(format_master):
    index_rst = \
"""
Welcome to the NWB Format Specification
=======================================


.. toctree::
    :numbered:
    :maxdepth: 8
    :caption: Table of Contents

    %s

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
""" % (format_master)

    return index_rst


####################################################
#  Define text with custom settings for the conf.py
####################################################
def get_custom_settings(utils_dir,
                        spec_dir='../../core',
                        namespace_filename='nwb.namespace.yaml',
                        default_namespace='core',
                        spec_output_dir="_format_auto_docs",
                        output_master='format_spec_main.inc',
                        output_dec_master='format_spec_doc.inc',
                        output_src_master='format_spec_sources.inc',
                        output_hierarchy_master='format_spec_type_hierarchy.inc',
                        show_yaml_src=True,
                        show_json_src=False,
                        show_hierarchy_plots=True,
                        generate_src_files=True,
                        generate_file_per_type=True,
                        subgroups_in_seperate_table=True,
                        abbrv_main_obj_in_table=True,
                        show_table_titles=True,
                        table_depth_char='.',
                        latex_clearpage_after_type=True,
                        resolve_type_inc=False,
                        **kwargs   # These are just consumed but not used. This is just a simple trick to allow us to just hand in the arguments from the command line parser directly without having to specify all the argument by hand
                        ):
    """
    Get the custom configuration settings for Sphinx and the autogeneration of sources from YAML.

    :param utils_dir: Folder where the utils directory is located with the generate_format_docs script

    :return: Tuple of strings with: i) the custom sphinx settings for the conf.py file and ii) the custom autogen settings for the conf_doc_autogen.py file
    """
    # Define the base html and latex settings
    custom_sphinx_settings = \
"""
############################################################################
#  CUSTOM CONFIGURATIONS ADDED BY THE NWB TOOL FOR GENERATING FORMAT DOCS
###########################################################################

import sphinx_rtd_theme
import os

# -- Generate sources from YAML---------------------------------------------------
spec_doc_rebuild_always = True   # Always rebuild the source docs from YAML even if the folder with the source files already exists

def run_doc_autogen(_):
   # Execute the autogeneration of Sphinx format docs from the YAML sources
   import sys
   import os
   conf_file_dir = os.path.dirname(os.path.abspath(__file__))
   sys.path.append(conf_file_dir)  # Need so that generate format docs can find the conf_doc_autogen file
   from conf_doc_autogen import spec_output_dir

   if spec_doc_rebuild_always or not os.path.exists(spec_output_dir):
      sys.path.append('%s')  # needed to enable import of generate_format docs
      from utils.generate_format_docs import main as generate_docs
      generate_docs()

def setup(app):
   app.connect('builder-inited', run_doc_autogen)
   app.add_stylesheet("theme_overrides.css")  # overrides for wide tables in RTD theme
""" % utils_dir

    custom_sphinx_settings += \
"""
# -- Customize sphinx settings
numfig = True
autoclass_content = 'both'
autodoc_docstring_signature = True
autodoc_member_order = 'bysource'
add_function_parentheses = False


# -- HTML sphinx options
html_theme = "sphinx_rtd_theme"
html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]

# LaTeX Sphinx options
latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
'preamble':
'''
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{6}
%s
\setlistdepth{100}''',
}

""" %  r'\\usepackage{enumitem}'   # Force that the \\usepackage is rendered as raw string to ensure it appears correctly in the conf.py, i.e., with \\u

    # Add the input options ot the settings
    custom_autodoc_settings = \
"""
# -*- coding: utf-8 -*-
#Configuration file for generating sources for the format documentation from the YAML specification files

import os

# -- Input options for the specification files to be used -----------------------

# Directory where the YAML files for the namespace to be documented are located
spec_input_spec_dir = %s

# Name of the YAML (or JSON) file with the specification of the Namespace to be documented
spec_input_namespace_filename = %s

# Name of the default namespace in the file
spec_input_default_namespace = %s

""" % ("'%s'" % spec_dir,
       "'%s'" % namespace_filename,
       "'%s'" % default_namespace)

    # Add options for customizing the locations of output files
    custom_autodoc_settings += """
# -- Options for customizing the locations of output files

# Directory where the autogenerated files should be stored
spec_output_dir = %s

# Name of the master rst file that includes all the autogenerated docs
spec_output_master_filename = %s

# Name of the file where the main documentation goes
spec_output_doc_filename = %s

# Name of the file where the sources of the format spec go. NOTE: This file is only generated if
# spec_generate_src_file is enabled
spec_output_src_filename  = %s

# Name of the file containing the type hierarchy. (Included in spec_output_doc_filename)
spec_output_doc_type_hierarchy_filename = %s

""" % ('os.path.join(os.path.dirname(os.path.abspath(__file__)), "%s")' % spec_output_dir,
       "'%s'" % output_master,
       "'%s'" % output_dec_master,
       "'%s'" % output_src_master,
       "'%s'" % output_hierarchy_master)

    # Add custom generator options
    custom_autodoc_settings += \
"""
# -- Options for the generation of the documentation from source ----------------

# Should the YAML sources be included for the different modules
spec_show_yaml_src = %s

# Should the JSON sources be included for the different modules
spec_show_json_src = %s

# Show figure of the hierarchy of objects defined by the spec
spec_show_hierarchy_plots = %s

# Should the sources of the neurodata_types (JSON/YAML) be rendered in a separate section (True) or
# in the same location as the base documentation
spec_generate_src_file = %s

# Should separate .inc reStructuredText files be generated for each neurodata_type (True)
# or should all text be added to the main file
spec_file_per_type = %s

# Should top-level subgroups be listed in a seperate table or as part of the main dataset and attributes table
spec_show_subgroups_in_seperate_table = %s

# Appreviate the documentation of the main object for which a table is rendered in the table.
# This is commonly set to True as doc of the main object is alrready rendered as the main intro for the
# section describing the object
spec_appreviate_main_object_doc_in_tables = %s

# Show a title for the tables
spec_show_title_for_tables = %s

# Char to be used as prefix to indicate the depth of an object in the specification hierarchy
spec_table_depth_char = %s # 'â†’' '.'

# Add a LaTeX clearpage after each main section describing a neurodata_type. This helps in LaTeX to keep the ordering
# of figures, tables, and code blocks consistent in particular when the hierarchy_plots are included
spec_add_latex_clearpage_after_ndt_sections = %s

# Resolve includes to always show the full list of objects that are part of a type (True)
# or to show only the parts that are actually new to a current type while only linking to base types
spec_resolve_type_inc = %s
""" % (str(show_yaml_src),
       str(show_json_src),
       str(show_hierarchy_plots),
       str(generate_src_files),
       str(generate_file_per_type),
       str(subgroups_in_seperate_table),
       str(abbrv_main_obj_in_table),
       str(show_table_titles),
       "'%s'" % str(table_depth_char),
       str(latex_clearpage_after_type),
       str(resolve_type_inc))

    # Return the custom settings python script
    return  custom_sphinx_settings, custom_autodoc_settings

#######################################
#  Create text for our custom makefile
#######################################
def get_makefile(utilsdir="$(PWD)utils",
                 confdir="$(PWD)/source"):

    return \
"""
# Makefile for Sphinx documentation
#

# You can set these variables from the command line.
SPHINXOPTS     =
SPHINXBUILD    = sphinx-build
SPHINXAPIDOC   = sphinx-apidoc
PAPER          =
BUILDDIR       = build
SRCDIR         = ../src
RSTDIR         = source
PKGNAME        = pynwb
UTILSDIR       = %s
CONFDIR        = %s
""" % (utilsdir, confdir) + \
'''

# Internal variables.
PAPEROPT_a4     = -D latex_paper_size=a4
PAPEROPT_letter = -D latex_paper_size=letter
ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) source
# the i18n builder cannot share the environment and doctrees with the others
I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .

.PHONY: help clean html dirhtml singlehtml pickle json htmlhelp qthelp devhelp epub latex latexpdf text man changes linkcheck doctest gettext fulldoc allclean

help:
	@echo "To update documentation sources from the format specification please use \`make apidoc'"
	@echo ""
	@echo "To build the documenation please use \`make <target>' where <target> is one of"
	@echo "  fulldoc    to rebuild the apidoc, html, and latexpdf all at once"
	@echo "  html       to make standalone HTML files"
	@echo "  dirhtml    to make HTML files named index.html in directories"
	@echo "  singlehtml to make a single large HTML file"
	@echo "  pickle     to make pickle files"
	@echo "  json       to make JSON files"
	@echo "  htmlhelp   to make HTML files and a HTML help project"
	@echo "  qthelp     to make HTML files and a qthelp project"
	@echo "  devhelp    to make HTML files and a Devhelp project"
	@echo "  epub       to make an epub"
	@echo "  latex      to make LaTeX files, you can set PAPER=a4 or PAPER=letter"
	@echo "  latexpdf   to make LaTeX files and run them through pdflatex"
	@echo "  text       to make text files"
	@echo "  man        to make manual pages"
	@echo "  texinfo    to make Texinfo files"
	@echo "  info       to make Texinfo files and run them through makeinfo"
	@echo "  gettext    to make PO message catalogs"
	@echo "  changes    to make an overview of all changed/added/deprecated items"
	@echo "  linkcheck  to check all external links for integrity"
	@echo "  doctest    to run all doctests embedded in the documentation (if enabled)"
	@echo "  apidoc     to to build RST from source code"
	@echo "  clean      to clean all documents built by Sphinx in _build"
	@echo "  allclean   to clean all autogenerated documents both from Sphinx and apidoc"

allclean:
	-rm -rf $(BUILDDIR)/* $(RSTDIR)/$(PKGNAME)* $(RSTDIR)/modules.rst
	-rm $(RSTDIR)/_format_auto_docs/*.png
	-rm $(RSTDIR)/_format_auto_docs/*.pdf
	-rm $(RSTDIR)/_format_auto_docs/*.rst
	-rm $(RSTDIR)/_format_auto_docs/*.inc

clean:
	-rm -rf $(BUILDDIR)/* $(RSTDIR)/$(PKGNAME)* $(RSTDIR)/modules.rst

html:
	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
	@echo
	@echo "Build finished. The HTML pages are in $(BUILDDIR)/html."

dirhtml:
	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
	@echo
	@echo "Build finished. The HTML pages are in $(BUILDDIR)/dirhtml."

singlehtml:
	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
	@echo
	@echo "Build finished. The HTML page is in $(BUILDDIR)/singlehtml."

pickle:
	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
	@echo
	@echo "Build finished; now you can process the pickle files."

json:
	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
	@echo
	@echo "Build finished; now you can process the JSON files."

htmlhelp:
	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
	@echo
	@echo "Build finished; now you can run HTML Help Workshop with the" \
	      ".hhp project file in $(BUILDDIR)/htmlhelp."

qthelp:
	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
	@echo
	@echo "Build finished; now you can run "qcollectiongenerator" with the" \
	      ".qhcp project file in $(BUILDDIR)/qthelp, like this:"
	@echo "# qcollectiongenerator $(BUILDDIR)/qthelp/sample.qhcp"
	@echo "To view the help file:"
	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/sample.qhc"

devhelp:
	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
	@echo
	@echo "Build finished."
	@echo "To view the help file:"
	@echo "# mkdir -p $$HOME/.local/share/devhelp/sample"
	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/sample"
	@echo "# devhelp"

epub:
	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
	@echo
	@echo "Build finished. The epub file is in $(BUILDDIR)/epub."

latex:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo
	@echo "Build finished; the LaTeX files are in $(BUILDDIR)/latex."
	@echo "Run \`make' in that directory to run these through (pdf)latex" \
	      "(use \`make latexpdf' here to do that automatically)."

latexpdf:
	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
	@echo "Running LaTeX files through pdflatex..."
	$(MAKE) -C $(BUILDDIR)/latex all-pdf
	@echo "pdflatex finished; the PDF files are in $(BUILDDIR)/latex."

text:
	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
	@echo
	@echo "Build finished. The text files are in $(BUILDDIR)/text."

man:
	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
	@echo
	@echo "Build finished. The manual pages are in $(BUILDDIR)/man."

texinfo:
	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
	@echo
	@echo "Build finished. The Texinfo files are in $(BUILDDIR)/texinfo."
	@echo "Run \`make' in that directory to run these through makeinfo" \
	      "(use \`make info' here to do that automatically)."

info:
	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
	@echo "Running Texinfo files through makeinfo..."
	make -C $(BUILDDIR)/texinfo info
	@echo "makeinfo finished; the Info files are in $(BUILDDIR)/texinfo."

gettext:
	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
	@echo
	@echo "Build finished. The message catalogs are in $(BUILDDIR)/locale."

changes:
	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
	@echo
	@echo "The overview file is in $(BUILDDIR)/changes."

linkcheck:
	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
	@echo
	@echo "Link check complete; look for any errors in the above output " \
	      "or in $(BUILDDIR)/linkcheck/output.txt."

doctest:
	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
	@echo "Testing of doctests in the sources finished, look at the " \
	      "results in $(BUILDDIR)/doctest/output.txt."

apidoc:
	PYTHONPATH=$(UTILSDIR):$(CONFDIR):$(PYTHONPATH) python $(UTILSDIR)/generate_format_docs.py
	@echo
	@echo "Generate rst source files from NWB spec."

fulldoc:
	$(MAKE) allclean
	@echo
	@echo "Rebuilding apidoc, html, latexpdf"
	$(MAKE) apidoc
	$(MAKE) html
	$(MAKE) latexpdf
'''

##########################################
#  Create the argpars command line parser
##########################################
def define_cl_args():
    """
    Create the argument parser for the script
    :return: argparse.ArgumentParser
    """

    parser = argparse.ArgumentParser(description='Create format specification SPHINX documenation for an NWB extension.',
                                     add_help=True,
                                     epilog="\n Copyright: Lawrence Berkeley National Laboratory: 2017",
                                     formatter_class=RawDescriptionDefaultHelpArgParseFormatter)
    parser.add_argument('--project', dest='project', action='store', type=str, required=True,
                        help='Name of the project')
    parser.add_argument('--author', dest='author', action='store', type=str, required=True,
                        help='Name of the author(s). Enclose in "..." if contains whitespaces')
    parser.add_argument('--version', dest='version', action='store', type=str, required=True,
                        help='Version of the project/docs')
    parser.add_argument('--release', dest='release', action='store', type=str, required=True,
                        help='Release of the project/docs')
    parser.add_argument('--language', dest='language', action='store', type=str, required=False,
                        help='Document language', default='English')
    parser.add_argument('--master', dest='master', action='store', type=str, required=False,
                        help='Master document name', default='index.rst')
    parser.add_argument('--format_master', dest='format_master', action='store', type=str, required=False,
                        help='Master document name for the format documentation', default='format.rst')
    parser.add_argument('--output', dest='output', action='store', type=str, required=True,
                        help='Project directory for the project')
    parser.add_argument('--spec_dir', dest='spec_dir', action='store', type=str, required=True,
                        help='Directory where the format specification YAML/JSON source files are located')
    parser.add_argument('--namespace_filename', dest='namespace_filename', action='store', type=str, required=True,
                        help='Name of the format specification YAML/JSON source file with the namespace')
    parser.add_argument('--default_namespace', dest='default_namespace', action='store', type=str, required=True,
                        help='Name of the default namespace to be rendered in the documentation')
    parser.add_argument('--spec_output_dir', dest='spec_output_dir', action='store', type=str, required=False,
                        help='Name of the folder within the documentation sources directory where the autogenerated sources should be stored', default="_format_auto_docs")
    parser.add_argument('--output_master', dest='output_master', action='store', type=str, required=False,
                        help='Name of the master reStructuredText file combining all autogenerated docs.', default="format_spec_main.inc")
    parser.add_argument('--output_dec_master', dest='output_dec_master', action='store', type=str, required=False,
                        help='Name of the master reStructuredText file with all the description docs.', default="format_spec_doc.inc")
    parser.add_argument('--output_src_master', dest='output_src_master', action='store', type=str, required=False,
                        help='Name of the master reStructuredText file with all the YAML/JSON source docs.', default="format_spec_sources.inc")
    parser.add_argument('--output_hierarchy_master', dest='output_hierarchy_master', action='store', type=str, required=False,
                        help='Name of the master reStructuredText file with the hierarchy of types.', default="format_spec_type_hierarchy.inc")
    parser.add_argument('--utilsdir', dest='utilsdir', action='store', type=str, required=False,
                        help='Specify where the tool for generating the sources from the YAML files will be located for the new format specification repo. Leave the default value if --copy-utils is set to True.', default="$(PWD)/utils")
    parser.add_argument('--copy_utils', dest='copy_utils', action='store', type=bool_type, required=False, default=True,
                        help="Disable copying of the utils folder from nwb-schema. If set then --utildir should be specified.")
    parser.add_argument('--resolve_type_inc', dest='resolve_type_inc', action='store', type=bool_type, required=False, default=False,
                        help="Always resolve type includes to show the full spec of an object including inherited components?")
    parser.add_argument('--latex_clearpage_after_type', dest='latex_clearpage_after_type', action='store', type=bool_type, required=False, default=True,
                        help="Add clearpage command in latex after each neurodata_type to esnure figures always appear in the right section at the cost of adding empty space between sections.")
    parser.add_argument('--table_depth_char', dest='table_depth_char', action='store', type=str, required=False, default='.',
                        help="Char to be used to indent entries in desciption tables to indicate the depth of the object.")
    parser.add_argument('--abbrv_main_obj_in_table', dest='abbrv_main_obj_in_table', action='store', type=bool_type, required=False, default=True,
                        help="Appreviate the description of the main object in the description tables?")
    parser.add_argument('--subgroups_in_seperate_table', dest='subgroups_in_seperate_table', action='store', type=bool_type, required=False, default=True,
                        help="Render the description of top level subgroups in seperate tables rather than as part of the attributes/dataset table?.")
    parser.add_argument('--generate_file_per_type', dest='generate_file_per_type', action='store', type=bool_type, required=False, default=True,
                        help="Generate separate reStructuredText files with .inc ending for each type/neurodata_type rather than rendering all description in a single file?")
    parser.add_argument('--generate_src_file', dest='generate_src_file', action='store', type=bool_type, required=False, default=True,
                        help="Generate seperate reStructuredText files for the YAML/JSON sources rather than including them in the desription files?")
    parser.add_argument('--show_hierarchy_plots', dest='show_hierarchy_plots', action='store', type=bool_type, required=False, default=True,
                        help="Generate and show plots of the hierarchy for each tyep/neurodata_type?")
    parser.add_argument('--show_json_src', dest='show_json_src', action='store', type=bool_type, required=False, default=False,
                        help="Show the source specification as JSON?")
    parser.add_argument('--show_yaml_src', dest='show_yaml_src', action='store', type=bool_type, required=False, default=True,
                        help="Show the source specification as YAML.")
    parser.add_argument('--custom_description', dest='custom_description', action='store', type=str, required=False, default=None,
                        help="Name of the custom RST file where further text for the description of the extension should be added. If not set then the custom description section will be omitted.")
    parser.add_argument('--external_description', dest='external_description', action='store', type=str, required=False, default=None,
                        help='Path to the rst file that should be included via a reference in the description documentation. Typically this file will be provided alongside with the spec_dir.')
    parser.add_argument('--custom_release_notes', dest='custom_release_notes', action='store', type=str, required=False, default=None,
                        help="Name of the custom RST file where further text for release notes for the extension should be added. If not set then the custom release_notes section will be omitted.")
    parser.add_argument('--external_release_notes', dest='external_release_notes', action='store', type=str, required=False, default=None,
                        help='Path to the rst file that should be included via a reference in the release notes documentation. Typically this file will be provided alongside with the spec_dir.')
    return parser


#######################################
#  Run sphinx-quickstart
#######################################
def init_sphinx(project, author, version, release, language, sphinx_master, output):

    command = ['sphinx-quickstart',
               '--quiet',
               '--sep',
               '-p',
               project,
               '-a',
               author,
               '-v',
               version,
               '-r',
               release,
               '-l',
               language,
               '--master',
               sphinx_master,
               '--ext-ifconfig',
               '--ext-autodoc',
               '--no-makefile',
               output]
    try:
        check_call(command, shell=False)
    except CalledProcessError:
        exit(0)

###########################################
#  Write the custom configuration settings
###########################################
def write_custom_conf(output, **kwargs):
    # Write the custom settings files
    custom_sphinx_settings, custom_doc_autogen_settings = get_custom_settings(output, **kwargs)
    outfilename = os.path.join(output, 'source/conf.py')
    outfile = open(outfilename, 'a')
    outfile.write(custom_sphinx_settings)
    outfile.close()
    # Write the custom doc autogen settings
    outfilename = os.path.join(output, 'source/conf_doc_autogen.py')
    outfile = open(outfilename, 'a')
    outfile.write(custom_doc_autogen_settings)
    outfile.close()

#######################################
#  Write RTD theme overwrites
#######################################
def write_theme_overwrites(output):
    static_path = os.path.join(output, 'source/_static')
    if not os.path.exists(static_path):
        os.mkdir(static_path)
    outfilename = os.path.join(static_path, 'theme_overrides.css')
    outfile = open(outfilename, 'w')
    outfile.write(get_theme_overwrites())
    outfile.close()

#######################################
#  Write custom makefile
#######################################
def write_makefile(output, utilsdir):
    outfilename = os.path.join(output, 'Makefile')
    outfile = open(outfilename, 'w')
    outfile.write(get_makefile(utilsdir))
    outfile.close()

#######################################
#  Write format rst
#######################################
def write_format_rst(output, format_master, project, spec_output_dir, output_master, custom_description=None, custom_release_notes=None):
    outfilename = os.path.join(output, 'source/%s' % format_master)
    outfile = open(outfilename, 'w')
    outfile.write(get_format_rst(spec_output_dir=spec_output_dir,
                                 output_master=output_master,
                                 project=project,
                                 custom_description=custom_description,
                                 custom_release_notes=custom_release_notes))
    outfile.close()

######################################
#  Write the custom description file
######################################
def write_custom_description(output, custom_description, external_description):
    outfilename = os.path.join(output, 'source/%s' % custom_description if custom_description is not None else "format_description.rst")
    custom_description_text = None
    if external_description is not None:
        custom_description_text = ".. include:: %s\n" % os.path.join(
            os.path.relpath(os.path.dirname(os.path.abspath(external_description)),
                            start=os.path.dirname(os.path.abspath(outfilename))),
            os.path.basename(external_description))
        #print(os.path.abspath(external_description))
        #print(os.path.abspath(outfilename))
        #print(os.path.relpath(os.path.abspath(external_description),
        #                      start=os.path.dirname(os.path.abspath(outfilename))))
    elif custom_description is not None:
        custom_description_text = \
"""
Overview
========

.. note::
    Add the description of your format/extension here
"""
    if custom_description_text is not None:
        outfile = open(outfilename, 'w')
        outfile.write(custom_description_text)
        outfile.close()
        return os.path.basename(outfilename)
    else:
        return None

######################################
#  Write the custom description file
######################################
def write_custom_release_notes(output, custom_release_notes, external_release_notes):
    outfilename = os.path.join(output, 'source/%s' % custom_release_notes if custom_release_notes is not None else 'format_release_notes.rst')
    custom_release_notes_text = None
    if external_release_notes is not None:
        custom_release_notes_text = ".. include:: %s\n" % os.path.join(
            os.path.relpath(os.path.dirname(os.path.abspath(external_release_notes)),
                            start=os.path.dirname(os.path.abspath(outfilename))),
            os.path.basename(external_release_notes))
    elif custom_release_notes is not None:
        custom_release_notes_text = \
"""
Release Notes
=============

.. note::
    Add the release notes of your format/extension here
"""
    if custom_release_notes_text is not None:
        outfile = open(outfilename, 'w')
        outfile.write(custom_release_notes_text)
        outfile.close()
        return os.path.basename(outfilename)
    else:
        return None

#########################################################################
#  Write custom index rst and delete the default one created by sphinx
########################################################################
def write_index_rst(output, format_master, master, sphinx_master):
    os.remove(os.path.join(output, 'source/%s.rst' % sphinx_master))
    outfilename = os.path.join(output, 'source/%s' % master)
    outfile = open(outfilename, 'w')
    outfile.write(get_index_rst(format_master=format_master))
    outfile.close()

#######################################
#  Write the readme file
#######################################
def write_readme(output, custom_description, custom_release_notes, copy_utils):
    outfilename = os.path.join(output, 'Readme.md')
    outfile = open(outfilename, 'w')
    outfile.write(get_readme(custom_description=custom_description,
                             custom_release_notes=custom_release_notes,
                             copy_utils=copy_utils))
    outfile.close()

#######################################
#  Copy the utils and licences
#######################################
def copy_utils(output):
    utilsdir = os.path.dirname(os.path.abspath(__file__))
    try:
        command = ['cp',
                   '-r',
                   utilsdir,
                   output]
        check_call(command, shell=False)
        command = ['cp',
               os.path.join(utilsdir, '../../Legal.txt'),
               os.path.join(output, 'utils')]
        check_call(command, shell=False)
        command = ['cp',
               os.path.join(utilsdir, '../../license.txt'),
               os.path.join(output, 'utils')]
        check_call(command, shell=False)
    except CalledProcessError:
        print("Copy of utils dir failed: " + str(command))

    except CalledProcessError:
        print("Copy of utils dir failed: " + str(command))


#######################################
#  MAIN
#######################################
def main():
    parser = define_cl_args()
    clargs = vars(parser.parse_args())
    clargs['output'] = os.path.abspath(clargs['output'])
    sphinx_master = 'index'  # This is just a temporary master file that sphinx-quickstart will generate. We'll delete that file and write our own custom index file later
    init_sphinx(project=clargs['project'],
                author=clargs['author'],
                version=clargs['version'],
                release=clargs['release'],
                language=clargs['language'],
                sphinx_master=sphinx_master,
                output=clargs['output'])
    write_theme_overwrites(output=clargs['output'])
    write_custom_conf(output=clargs['output'])
    write_makefile(output=clargs['output'], utilsdir=clargs['utilsdir'].rstrip('/'))
    custom_description_file = write_custom_description(output=clargs['output'],
                                                       custom_description=clargs['custom_description'],
                                                       external_description=clargs['external_description'])
    custom_release_notes_file = write_custom_release_notes(output=clargs['output'],
                                                           custom_release_notes=clargs['custom_release_notes'],
                                                           external_release_notes=clargs['external_release_notes'])
    write_format_rst(output=clargs['output'],
                     format_master=clargs['format_master'],
                     project=clargs['project'],
                     spec_output_dir=clargs['spec_output_dir'],
                     output_master=clargs['output_master'],
                     custom_description=custom_description_file,
                     custom_release_notes=custom_release_notes_file)
    write_index_rst(output=clargs['output'],
                    format_master=clargs['format_master'],
                    master=clargs['master'],
                    sphinx_master=sphinx_master)
    if clargs['copy_utils']:
        copy_utils(output=clargs['output'])
    write_readme(output=clargs['output'],
                 custom_description=clargs['custom_description'],
                 custom_release_notes=clargs['custom_release_notes'],
                 copy_utils=clargs['copy_utils'])


if __name__ == "__main__":
    main()


#  python init_sphinx_extension_doc.py --project test --author "Oliver Ruebel" --version 1.2.3 --release alpha --master index.rst --output ../testproject --spec_dir ../../core --namespace_filename nwb.namespace.yaml --default_namespace core --custom_description format_description.rst --custom_release_notes format_release_notes.rst --external_description ../format/source/format_description.inc --external_release_notes ../format/source/format_release_notes.inc